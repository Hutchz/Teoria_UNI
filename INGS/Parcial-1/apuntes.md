# Tema 1

## **Definición software**

Definimos el **software** como la suma de *programas*, *datos* y *documentación*. El software es un elemento **lógico** el cuál es **desarrollado a medida**, el problema es que al cabo del tiempo se acaba **deteriorando**. 

## **Crisis del software**

La ingeniería del software surge a raiz de una crisis en la decada de 1970. Esta crisis fue originada debido a que el *hardware era cada vez más potente*, había una *mayor demanda* de software, *no había metodologías y técnicas para desarrollarlo*... Esta crisis también tuvo varios ***síntomas***:
* La **productividad** de los desarrolladores disminuyo.
* Las **espectativas** de los sistemas no responden a las expectativas de los usuarios.
* Los programas no eran **fiables** fallaban mucho.
* La **calidad** era pésima.
* Los **costes** elevados.
* El **mantenimiento** costoso.
* Los **plazos** no se cumplen.

Podemos concluir pues, que las consecuencias más notorias de esta crisis fueron la **baja productividad** y la **baja calidad**.

Pero como todo en está vida, había una solución. Esta solución se basaba en aplicar la ingeniería del software en la construcción de sistemas informáticos.

## **Proyectos, productos y procesos**

Para comprender que es un proyecto, debemos distinguirlo de un trabajo operativo:
* En un **trabajo operativo** se efectuan permanentemente actividades que generan un mismo producto o proveen un *servicio repetitivo*.
* Un **proyecto** es un **esfuerzo temporal** que se lleva a cabo para crear un producto, servicio o resultado único.

Para desarrollar un prollecto es necesario un proceso, el **proceso software**.

## **Ingeniería del software**

El proceso software es elegido a través de la **ingeniería del software**. Esta ingeniería tiene ***desafíos*** tales como **reducir el coste**, **mejorar la calidad** y, **explotar y aprovechar** el potencial de un hardware.

Podemos definir a la ingeniería del software como: "*El establecimiento y uso de principios de ingeniería robustos, orientados a obtener económicamente software que sea fiable y funcione eficientemente sobre máquinas reales.*"

Los ***objetivos*** básicos son **conseguir un producto** y **conducir un proceso de desarrollo y mantenimiento**.

También hay que tener en cuenta que esta ingeniería está compuesta por varias disciplinas tales como **economía**, **ingeniería**, **informática**, **psicología** y **gestión**.

Luego existen fundamentos y técnicas para el desarrollo del software. Se deben tener en cuenta:
* **Métodos**, que definen cómo construir el software desde el punto de vista técnico.
* **Herramientas**, que proporcionan un soporte automático o semiautomático para los métodos.
* **Procedimientos**, los cuales son puntos de unión entre métodos y herramientas.

Por último tenemos varios tipos de actividades: 
* *Desarrollo*: Análisis, diseño, codificación, pruebas, instalación y mantenimiento.
* *Control*: Evaluan y aseguran la calidad del software.
* *Gestión*: Planificación, estimación, seguimiento, dirección...
* *Operación*: Entrega, puesta en marcha, formación...

# Tema 2
Un **proceso de software** es una serie de actividades relacionadas que conducen a la elaboración de un producto de software

En un proceso software se usan **metodologías**. Las metododologías se encargan de optimizar el proceso y producto software. A parte, guián en la planificación y en el desarrollo del software. Las metodologías definen una estrategia global para enfrentarse con el proyecto: *Fases*, *Productos (final e indermedios)*, *Procedimientos y herramientas*, *Criterios de evaluación*.

También tenemos el **ciclo de vida**. Es el conjunto de fases por las que pasa el sistema que se está desarrollando desde que nace la idea inicial hasta que el software es retirado o reemplazado.

Las metodologías definen el ciclo de vida que más se adecúe a las condiciones y características del desarrollo.

Existen varios tipos de metodologías:
* **Pesadas o tradicionales**: Fases bien definidas, entregadas al final, requisitos y planificación bien definidos.
* **Ágiles**: Continua interacción con el cliente, muchas entregas parciales y ciclo de vida iterativos más cortos.
* **Centrados en el usuario**: Interacción continua con el usuario.

### Metodologías Tradicionales

* **Cascada simple**.
* **Cascada con refinamiento**.
* **Incremental**. El problema se divide en sub-problemas.
* **Iterativo**. Se van creando versiones del producto.
* **Incremental-Iterativo (unificado)**.

### Metodología Metrica

Desarrollada por españita.

### Metodología Ágil

* **XP (eXtreme Programming)**.
* **KANBAN**.
* **SCRUM**.

### Metodología centrada en el usuario

Creación de productos que resuelvan necesidades concretas de sus usuarios finales.

## Usabilidad
La usabilidad es la medida en la que un producto se puede usar por determinados usuarios para conseguir objetivos con efectividad, eficiencia y satisfacción en un contexto de uso especificado.

Las métricas generales de la usabilidad son:
* **Exactitud**: Número de errores cometidos por los sujetos de prueba.
* **Tiempo requerido para concluir la actividad**.
* **Recuerdo**.
* **Respuesta emocional**.

# Tema 3

En el desarrollo del software existen unas **actividades tempranas en el desarrollo de software**.

Se definen, las *fases*, el *orden* y las *entradas y salidas*, en base a las características del proyecto.

Se definen *estándares*, *métodos*, *técnicas* y *herramientas*.

Se definen *objetivos*, *entradas* y *salidas*.

Se definen *criterios de calidad y validación* de acuerdo con la *especificación de requisitos*, *resultados esperados*, *plan de validación*... Debe haber un acuerdo entre todos los participantes en el proyecto.

Se definen ***hitos*** los cuales tienen ligados *productos*. Se consigue un hito cuando se ha revisado la calidad de uno o más productos y se han aceptado. Tras cada hito se debería generar un informe de progreso del proyecto.

Se crea el *equipo de desarrollo*.

Se definen los mecanismos de seguimiento y control.

# Tema 4

En la ingeniería del software tenemos una fase a la que denominamos análisis. En esta fase se hace la **captura de requisitos**. Los requisitos pueden ser:
* **Requisitos de usuario**. Son declaraciones de las funciones o acciones que los distintos usuarios pueden realizar con la aplicación y bajo qué restricciones.
* **Requisitos de software**. Especifican de una manera completa *qué debe hacer y cómo debe comportarse el software* para cumplir con los objetivos de la aplicación.

En la fase de análisis tenemos varias tareas: *Analizar el problema*, *analizar a los usuarios y las tareas*, *educir requisitos (identificarlos)*, *analizar requisitos*, *representar los requisitos (modelarlos)* y por último *validarlos*.

Tenemos varios tipos de requisitos:
* **Funcionales**: Son acciones fundamentales que tienen que tener lugar en la ejecución del software.
* **No funcionales**: Representan características o cualidades generales que se esperan del software para conseguir su propósito. Tenemos no funcionales en relación con la *interfaz y la usabilidad*, *operacionales*, *documentación*, *seguridad*, *rendimiento*...

Las maquetas no se usan después de haberlas presentado, se tiran. Son solo para que el cliente se haga una idea de lo que se va a hacer.

Los requisitos deben ser **válidos**, para eso deben ser:
* **Completos**: Todo lo que el software tiene que hacer está recogido en el conjunto de requisitos.
* **No ambiguos**: Cada requisito debe tener una sola interpretación.
* **Relevantes**: Importancia para el sistema software a implementar.
* **Traceables**: Cada acción de diseño debe corresponderse con algún requisito, y debe comprobarse.
* **Correctos**: Cada requisito establecido debe representar algo requerido por el usuario para el sistema que se construye.
* **Consistentes**: Ningún requisito puede estar en conflicto con otro.